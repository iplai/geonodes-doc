# 曲面

## Examples

### Initialization

A Mesh can be initialized:
- by typecasting another geometry
- or by using a constructor such as `Cube`, `Line`, `IcoSphere`, `UVSphere`

```python
import geonodes as gn

with gn.Tree("Test") as tree:

    # Typecasting the tree input geometry
    
    mesh = gn.Mesh(tree.ig)
    
    # We create a cube
    
    cube = gn.Mesh.Cube()
    cube.set_position(offset=(0, 0, 2))
    
    # We return the two meshes
    
    tree.og = mesh + cube
```

### Vertices position

The vertices position is given by the property `position` of domain `verts`: `mesh.verts.position`.
To change the position of a selection of vertices, use the list syntax on the `verts` property: `mesh.verts[selection]`.

```python
import geonodes as gn

with gn.Tree("Test") as tree:
    
    sphere = gn.Mesh.IcoSphere(radius=2, subdivisions=3)
    
    # Offset position
    sphere.verts[(sphere.verts.index % 5).equal(0)].position += (0, 0, 1)
    
    # Absolute position
    v = sphere.verts.position
    v.z = -3
    sphere.verts[10:20].position = v
    
    tree.og = sphere
```

### Material and shading

The example below shows how the set material on a mesh, either by using the `set_material` method of mesh or
by using the `material` property of `faces` domain.

```python
import geonodes as gn

with gn.Tree("Test") as tree:
    
    # ----- Modifier parameters

    # We read the materials given by the user
    mat1 = gn.Material.Input(None, "Base material")
    mat2 = gn.Material.Input(None, "Selection material")
    
    # Let's ask from the starting and ending indices of the face selection
    
    start = gn.Integer.Input(10, "Selection start")
    end   = gn.Integer.Input(20, "Selection end")
    
    # Shading smooth or not
    shade_smooth = gn.Boolean.Input(None,"Shade smooth")
    
    # Let's use an icosphere
    mesh = gn.Mesh.IcoSphere(subdivisions=3)
    
    # ----- Let's go
    
    # Material 1 as base material
    mesh.set_material(mat1)
    
    # Material 2 on a selection of faces
    mesh.faces[start:end].material = mat2
    
    # We smooth (or not)
    mesh.faces.shade_smooth = shade_smooth

    tree.og = mesh
```

## Extrusion

Extrusion uses `extrude` property of extrudable domains: `verts`, `faces` or `edges`. The method returns two [Boolean](Boolean.md)
which can be used to select the newly created faces.

The example below shows how to inset a selection of faces and then extrude the top faces.


```python
import geonodes as gn

with gn.Tree("Test") as tree:
    
    # ----- Modifier parameters
    
    # Let's ask from the starting and ending indices of the faces
    # to extrude
    
    start = gn.Integer.Input(10, "Extrusion start")
    end   = gn.Integer.Input(20, "Extrusion end")
    
    inset = gn.Float.Input(.5, "Inset factor", min_value=0, max_value=1)

    # ----- Let's
    
    # Let's use an icosphere
    mesh = gn.Mesh.IcoSphere(subdivisions=3)
    
    # inset: extrude with offset_scale = 0 followed by a scale
    
    # First inset
    top, side = mesh.faces[start:end].extrude(offset_scale=0)
    
    # First inset
    mesh.faces[top].scale_uniform(inset)
    
    # True extrusion
    mesh.faces[top].extrude()
    
    tree.og = mesh
```

### Boolean operations

The three possible boolean operations on meshes can be done using the three methods:
- `boolean_union`
- `boolean_intersect`
- `boolean_difference`

The three methods accept several meshes as arguments.

```python
import geonodes as gn

with gn.Tree("Test") as tree:
    
    # We will perform the boolean operation with a cylinder and a thick plane
    cyl, _, _, _ = gn.Mesh.Cylinder(depth=5)
    plane = gn.Mesh.Cube().transform(scale=(4.1, 4.1, .25))
    
    # ----- Union
    
    mesh1 = gn.Mesh.UVSphere(radius=2)
    mesh1.boolean_union(cyl, plane)
    
    mesh1.transform(translation=(5, 0, 0))
    
    # ----- Intersection
    
    mesh2 = gn.Mesh.UVSphere(radius=2)
    mesh2.boolean_intersect(cyl, plane)
    
    # ----- Difference
    
    mesh3 = gn.Mesh.UVSphere(radius=2)
    mesh3.boolean_difference(cyl, plane)
    
    mesh3.transform(translation=(-5, 0, 0))
    
    # ----- The 3 operations as a result
    
    tree.og = mesh1 + mesh2 + mesh3
```
Final

``` python
from imare import *
init_modules(__file__, "imare", "geonodes")
flush_data()

import geonodes as gn
from geonodes.nodes import nodes

mat_a = bpy.data.materials.new("a")
mat_a.diffuse_color = (1, 0, 0, 1)

mat_b = bpy.data.materials.new("b")
mat_b.diffuse_color = (0, 0, 1, 1)

# Vertices position
with gn.Tree("Geometry Nodes", reroute=False, shift=False) as tree:

    sphere = gn.Mesh.IcoSphere(radius=2, subdivisions=3)

    index = nodes.Index().index

    sphere.verts[index % 5 == 0].position += (0, 0, 1)

    # Absolute position
    pos = sphere.verts.position
    sphere.verts[10:20].position = (pos.x, pos.y, -3)

    tree.og = sphere

# Material and shading
with gn.Tree("Geometry Nodes", reroute=False, shift=False) as tree:

    # ----- Modifier parameters

    # We read the materials given by the user
    mat1 = gn.Material.Input("a", "Base material")
    mat2 = gn.Material.Input("b", "Selection material")

    # Let's ask from the starting and ending indices of the face selection

    start = gn.Integer.Input(10, "Selection start", 0)
    end = gn.Integer.Input(20, "Selection end", 0)

    # Shading smooth or not
    shade_smooth = gn.Boolean.Input(None, "Shade smooth")

    # Let's use an icosphere
    mesh = gn.Mesh.IcoSphere(subdivisions=3)

    # ----- Let's go

    # Material 1 as base material
    mesh.set_material(material=mat1)

    # Material 2 on a selection of faces
    mesh.faces[start:end].material = mat2

    # We smooth (or not)
    mesh.faces.shade_smooth = shade_smooth

    tree.og = mesh

# Extrusion
with gn.Tree("Geometry Nodes", reroute=False, shift=False) as tree:

    # ----- Modifier parameters

    # Let's ask from the starting and ending indices of the faces
    # to extrude

    start = gn.Integer.Input(10, "Extrusion start", 0)
    end = gn.Integer.Input(20, "Extrusion end", 0)

    inset = gn.Float.Input(.5, "Inset factor", 0, 1)

    # ----- Let's

    # Let's use an icosphere
    mesh = gn.Mesh.IcoSphere(subdivisions=3)

    # 内部挤压分为两个步骤: extrude with offset_scale = 0 followed by a scale

    # First inset
    top, side = mesh.faces[start:end].extrude(offset_scale=0)

    # Then inset
    mesh.faces[top].scale_uniform(inset)

    # True extrusion
    mesh.faces[top].extrude()

    tree.og = mesh

# Boolean operations
with gn.Tree("Geometry Nodes", reroute=False, shift=False) as tree:

    # We will perform the boolean operation with a cylinder and a thick plane
    cyl, _, _, _ = gn.Mesh.Cylinder(depth=5)

    plane = gn.Mesh.Cube().transform(scale=(4.1, 4.1, .25))

    # ----- Union

    mesh1 = gn.Mesh.UVSphere(radius=2)
    mesh1.boolean_union(cyl, plane)

    mesh1.transform(translation=(5, 0, 0))

    # ----- Intersection

    mesh2 = gn.Mesh.UVSphere(radius=2)
    mesh2.boolean_intersect(cyl, plane)

    # ----- Difference

    mesh3 = gn.Mesh.UVSphere(radius=2)
    mesh3.boolean_difference(cyl, plane)

    mesh3.transform(translation=(-5, 0, 0))

    # ----- The 3 operations as a result

    tree.og = mesh1 + mesh2 + mesh3


Tree({
    O.cube: {
        Mod.geometry_nodes: {
            "node_group": "Geometry Nodes",
        },
    },
}).load()
bpy.context.scene.frame_end = 90
```
